"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/next-redux-wrapper";
exports.ids = ["vendor-chunks/next-redux-wrapper"];
exports.modules = {

/***/ "(ssr)/./node_modules/next-redux-wrapper/es6/index.js":
/*!******************************************************!*\
  !*** ./node_modules/next-redux-wrapper/es6/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HYDRATE: () => (/* binding */ HYDRATE),\n/* harmony export */   createWrapper: () => (/* binding */ createWrapper),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-redux */ \"(ssr)/./node_modules/react-redux/dist/react-redux.mjs\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/router */ \"(ssr)/./node_modules/next/dist/api/router.js\");\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\n\n\n/**\n * Quick note on Next.js return types:\n *\n * Page.getInitialProps https://nextjs.org/docs/api-reference/data-fetching/getInitialProps\n * as-is\n *\n * App.getInitialProps: AppInitialProps https://nextjs.org/docs/advanced-features/custom-app\n * {pageProps: any}\n *\n * getStaticProps https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation\n * {props: any}\n *\n * getServerSideProps https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering\n * {props: any}\n */\nvar HYDRATE = '__NEXT_REDUX_WRAPPER_HYDRATE__';\nvar getIsServer = function () { return typeof window === 'undefined'; };\nvar getDeserializedState = function (initialState, _a) {\n    var _b = _a === void 0 ? {} : _a, deserializeState = _b.deserializeState;\n    return deserializeState ? deserializeState(initialState) : initialState;\n};\nvar getSerializedState = function (state, _a) {\n    var _b = _a === void 0 ? {} : _a, serializeState = _b.serializeState;\n    return serializeState ? serializeState(state) : state;\n};\nvar sharedClientStore;\nvar initStore = function (_a) {\n    var _b, _c, _d;\n    var makeStore = _a.makeStore, _e = _a.context, context = _e === void 0 ? {} : _e;\n    var createStore = function () { return makeStore(context); };\n    if (getIsServer()) {\n        var req = ((_b = context) === null || _b === void 0 ? void 0 : _b.req) || ((_d = (_c = context) === null || _c === void 0 ? void 0 : _c.ctx) === null || _d === void 0 ? void 0 : _d.req);\n        if (req) {\n            // ATTENTION! THIS IS INTERNAL, DO NOT ACCESS DIRECTLY ANYWHERE ELSE\n            // @see https://github.com/kirill-konshin/next-redux-wrapper/pull/196#issuecomment-611673546\n            if (!req.__nextReduxWrapperStore) {\n                req.__nextReduxWrapperStore = createStore(); // Used in GIP/GSSP\n            }\n            return req.__nextReduxWrapperStore;\n        }\n        return createStore();\n    }\n    // Memoize the store if we're on the client\n    if (!sharedClientStore) {\n        sharedClientStore = createStore();\n    }\n    return sharedClientStore;\n};\nvar createWrapper = function (makeStore, config) {\n    if (config === void 0) { config = {}; }\n    var makeProps = function (_a) {\n        var callback = _a.callback, context = _a.context, _b = _a.addStoreToContext, addStoreToContext = _b === void 0 ? false : _b;\n        return __awaiter(void 0, void 0, void 0, function () {\n            var store, nextCallback, initialProps, _c, state;\n            return __generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        store = initStore({ context: context, makeStore: makeStore });\n                        if (config.debug) {\n                            console.log(\"1. getProps created store with state\", store.getState());\n                        }\n                        // Legacy stuff - put store in context\n                        if (addStoreToContext) {\n                            if (context.ctx) {\n                                context.ctx.store = store;\n                            }\n                            else {\n                                context.store = store;\n                            }\n                        }\n                        nextCallback = callback && callback(store);\n                        _c = nextCallback;\n                        if (!_c) return [3 /*break*/, 2];\n                        return [4 /*yield*/, nextCallback(context)];\n                    case 1:\n                        _c = (_d.sent());\n                        _d.label = 2;\n                    case 2:\n                        initialProps = (_c) || {};\n                        if (config.debug) {\n                            console.log(\"3. getProps after dispatches has store state\", store.getState());\n                        }\n                        state = store.getState();\n                        return [2 /*return*/, {\n                                initialProps: initialProps,\n                                initialState: getIsServer() ? getSerializedState(state, config) : state,\n                            }];\n                }\n            });\n        });\n    };\n    var getInitialPageProps = function (callback) {\n        return function (context) { return __awaiter(void 0, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        // context is store — avoid double-wrapping\n                        if ('getState' in context) {\n                            return [2 /*return*/, callback && callback(context)];\n                        }\n                        return [4 /*yield*/, makeProps({ callback: callback, context: context, addStoreToContext: true })];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        }); };\n    };\n    var getInitialAppProps = function (callback) {\n        return function (context) { return __awaiter(void 0, void 0, void 0, function () {\n            var _a, initialProps, initialState;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, makeProps({ callback: callback, context: context, addStoreToContext: true })];\n                    case 1:\n                        _a = _b.sent(), initialProps = _a.initialProps, initialState = _a.initialState;\n                        return [2 /*return*/, __assign(__assign({}, initialProps), { initialState: initialState })];\n                }\n            });\n        }); };\n    };\n    var getStaticProps = function (callback) {\n        return function (context) { return __awaiter(void 0, void 0, void 0, function () {\n            var _a, initialProps, initialState;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, makeProps({ callback: callback, context: context })];\n                    case 1:\n                        _a = _b.sent(), initialProps = _a.initialProps, initialState = _a.initialState;\n                        return [2 /*return*/, __assign(__assign({}, initialProps), { props: __assign(__assign({}, initialProps.props), { initialState: initialState }) })];\n                }\n            });\n        }); };\n    };\n    var getServerSideProps = function (callback) {\n        return function (context) { return __awaiter(void 0, void 0, void 0, function () { return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, getStaticProps(callback)(context)];\n                case 1: return [2 /*return*/, _a.sent()];\n            }\n        }); }); };\n    }; // just not to repeat myself\n    var hydrate = function (store, state) {\n        if (!state) {\n            return;\n        }\n        store.dispatch({\n            type: HYDRATE,\n            payload: getDeserializedState(state, config),\n        });\n    };\n    var hydrateOrchestrator = function (store, giapState, gspState, gsspState, gippState) {\n        var _a;\n        if (gspState) {\n            // If GSP has run, then gspState will _not_ contain the data from GIP (if it exists), because GSP is run at build time,\n            // and GIP runs at request time. So we have to hydrate the GIP data first, and then do another hydrate on the gspState.\n            hydrate(store, giapState);\n            hydrate(store, gspState);\n        }\n        else if (gsspState || gippState || giapState) {\n            // If GSSP has run, then gsspState _will_ contain the data from GIP (if there is a GIP) and the GSSP data combined\n            // (see https://github.com/kirill-konshin/next-redux-wrapper/pull/499#discussion_r1014500941).\n            // If there is no GSP or GSSP for this page, but there is a GIP on page level (not _app), then we use the gippState.\n            // If there is no GSP or GSSP and no GIP on page level for this page, but there is a GIP on _app level, then we use the giapState.\n            hydrate(store, (_a = gsspState !== null && gsspState !== void 0 ? gsspState : gippState) !== null && _a !== void 0 ? _a : giapState);\n        }\n    };\n    var useHybridHydrate = function (store, giapState, gspState, gsspState, gippState) {\n        var events = (0,next_router__WEBPACK_IMPORTED_MODULE_1__.useRouter)().events;\n        var shouldHydrate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n        // We should only hydrate when the router has changed routes\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n            var handleStart = function () {\n                shouldHydrate.current = true;\n            };\n            events === null || events === void 0 ? void 0 : events.on('routeChangeStart', handleStart);\n            return function () {\n                events === null || events === void 0 ? void 0 : events.off('routeChangeStart', handleStart);\n            };\n        }, [events]);\n        // useMemo so that when we navigate client side, we always synchronously hydrate the state before the new page\n        // components are mounted. This means we hydrate while the previous page components are still mounted.\n        // You might think that might cause issues because the selectors on the previous page (still mounted) will suddenly\n        // contain other data, and maybe even nested properties, causing null reference exceptions.\n        // But that's not the case.\n        // Hydrating in useMemo will not trigger a rerender of the still mounted page component. So if your selectors do have\n        // some initial state values causing them to rerun after hydration, and you're accessing deeply nested values inside your\n        // components, you still wouldn't get errors, because there's no rerender.\n        // Instead, React will render the new page components straight away, which will have selectors with the correct data.\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\n            if (shouldHydrate.current) {\n                hydrateOrchestrator(store, giapState, gspState, gsspState, gippState);\n                shouldHydrate.current = false;\n            }\n        }, [store, giapState, gspState, gsspState, gippState]);\n    };\n    // giapState stands for getInitialAppProps state\n    var useWrappedStore = function (_a, displayName) {\n        var _b, _c, _d, _e, _f, _g;\n        if (displayName === void 0) { displayName = 'useWrappedStore'; }\n        var giapState = _a.initialState, initialProps = _a.initialProps, props = __rest(_a, [\"initialState\", \"initialProps\"]);\n        // getStaticProps state\n        var gspState = (props === null || props === void 0 ? void 0 : props.__N_SSG) ? (_b = props === null || props === void 0 ? void 0 : props.pageProps) === null || _b === void 0 ? void 0 : _b.initialState : null;\n        // getServerSideProps state\n        var gsspState = (props === null || props === void 0 ? void 0 : props.__N_SSP) ? (_c = props === null || props === void 0 ? void 0 : props.pageProps) === null || _c === void 0 ? void 0 : _c.initialState : null;\n        // getInitialPageProps state\n        var gippState = !gspState && !gsspState ? (_e = (_d = props === null || props === void 0 ? void 0 : props.pageProps) === null || _d === void 0 ? void 0 : _d.initialState) !== null && _e !== void 0 ? _e : null : null;\n        if (config.debug) {\n            console.log('4.', displayName, 'created new store with', {\n                giapState: giapState,\n                gspState: gspState,\n                gsspState: gsspState,\n                gippState: gippState,\n            });\n        }\n        var store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () { return initStore({ makeStore: makeStore }); }, []);\n        useHybridHydrate(store, giapState, gspState, gsspState, gippState);\n        var resultProps = props;\n        // order is important! Next.js overwrites props from pages/_app with getStaticProps from page\n        // @see https://github.com/zeit/next.js/issues/11648\n        if (initialProps && initialProps.pageProps) {\n            resultProps.pageProps = __assign(__assign({}, initialProps.pageProps), props.pageProps);\n        }\n        // just some cleanup to prevent passing it as props, we need to clone props to safely delete initialState\n        if ((_f = props === null || props === void 0 ? void 0 : props.pageProps) === null || _f === void 0 ? void 0 : _f.initialState) {\n            resultProps = __assign(__assign({}, props), { pageProps: __assign({}, props.pageProps) });\n            delete resultProps.pageProps.initialState;\n        }\n        // unwrap getInitialPageProps\n        if ((_g = resultProps === null || resultProps === void 0 ? void 0 : resultProps.pageProps) === null || _g === void 0 ? void 0 : _g.initialProps) {\n            resultProps.pageProps = __assign(__assign({}, resultProps.pageProps), resultProps.pageProps.initialProps);\n            delete resultProps.pageProps.initialProps;\n        }\n        return { store: store, props: __assign(__assign({}, initialProps), resultProps) };\n    };\n    var withRedux = function (Component) {\n        console.warn('/!\\\\ You are using legacy implementation. Please update your code: use createWrapper() and wrapper.useWrappedStore().');\n        //TODO Check if pages/_app was wrapped so there's no need to wrap a page itself\n        var WrappedComponent = function (props) {\n            var _a = useWrappedStore(props, WrappedComponent.displayName), store = _a.store, combinedProps = _a.props;\n            return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_redux__WEBPACK_IMPORTED_MODULE_2__.Provider, { store: store },\n                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Component, __assign({}, combinedProps))));\n        };\n        WrappedComponent.displayName = \"withRedux(\".concat(Component.displayName || Component.name || 'Component', \")\");\n        if ('getInitialProps' in Component) {\n            WrappedComponent.getInitialProps = Component.getInitialProps;\n        }\n        return WrappedComponent;\n    };\n    return {\n        getServerSideProps: getServerSideProps,\n        getStaticProps: getStaticProps,\n        getInitialAppProps: getInitialAppProps,\n        getInitialPageProps: getInitialPageProps,\n        withRedux: withRedux,\n        useWrappedStore: useWrappedStore,\n    };\n};\n// Legacy\n// eslint-disable-next-line import/no-anonymous-default-export\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function (makeStore, config) {\n    if (config === void 0) { config = {}; }\n    console.warn('/!\\\\ You are using legacy implementation. Please update your code: use createWrapper() and wrapper.withRedux().');\n    return createWrapper(makeStore, config).withRedux;\n});\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC1yZWR1eC13cmFwcGVyL2VzNi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsZ0JBQWdCLFNBQUksSUFBSSxTQUFJO0FBQzVCO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLG1CQUFtQixTQUFJLElBQUksU0FBSTtBQUMvQixjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0EsY0FBYyxTQUFJLElBQUksU0FBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMEQ7QUFDbkI7QUFDQztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtB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QUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdG9yZS1hcHAvLi9ub2RlX21vZHVsZXMvbmV4dC1yZWR1eC13cmFwcGVyL2VzNi9pbmRleC5qcz9iZWVlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICduZXh0L3JvdXRlcic7XG4vKipcbiAqIFF1aWNrIG5vdGUgb24gTmV4dC5qcyByZXR1cm4gdHlwZXM6XG4gKlxuICogUGFnZS5nZXRJbml0aWFsUHJvcHMgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9kYXRhLWZldGNoaW5nL2dldEluaXRpYWxQcm9wc1xuICogYXMtaXNcbiAqXG4gKiBBcHAuZ2V0SW5pdGlhbFByb3BzOiBBcHBJbml0aWFsUHJvcHMgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYWR2YW5jZWQtZmVhdHVyZXMvY3VzdG9tLWFwcFxuICoge3BhZ2VQcm9wczogYW55fVxuICpcbiAqIGdldFN0YXRpY1Byb3BzIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2Jhc2ljLWZlYXR1cmVzL2RhdGEtZmV0Y2hpbmcjZ2V0c3RhdGljcHJvcHMtc3RhdGljLWdlbmVyYXRpb25cbiAqIHtwcm9wczogYW55fVxuICpcbiAqIGdldFNlcnZlclNpZGVQcm9wcyBodHRwczovL25leHRqcy5vcmcvZG9jcy9iYXNpYy1mZWF0dXJlcy9kYXRhLWZldGNoaW5nI2dldHNlcnZlcnNpZGVwcm9wcy1zZXJ2ZXItc2lkZS1yZW5kZXJpbmdcbiAqIHtwcm9wczogYW55fVxuICovXG5leHBvcnQgdmFyIEhZRFJBVEUgPSAnX19ORVhUX1JFRFVYX1dSQVBQRVJfSFlEUkFURV9fJztcbnZhciBnZXRJc1NlcnZlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnOyB9O1xudmFyIGdldERlc2VyaWFsaXplZFN0YXRlID0gZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSwgX2EpIHtcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgZGVzZXJpYWxpemVTdGF0ZSA9IF9iLmRlc2VyaWFsaXplU3RhdGU7XG4gICAgcmV0dXJuIGRlc2VyaWFsaXplU3RhdGUgPyBkZXNlcmlhbGl6ZVN0YXRlKGluaXRpYWxTdGF0ZSkgOiBpbml0aWFsU3RhdGU7XG59O1xudmFyIGdldFNlcmlhbGl6ZWRTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgX2EpIHtcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgc2VyaWFsaXplU3RhdGUgPSBfYi5zZXJpYWxpemVTdGF0ZTtcbiAgICByZXR1cm4gc2VyaWFsaXplU3RhdGUgPyBzZXJpYWxpemVTdGF0ZShzdGF0ZSkgOiBzdGF0ZTtcbn07XG52YXIgc2hhcmVkQ2xpZW50U3RvcmU7XG52YXIgaW5pdFN0b3JlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIF9iLCBfYywgX2Q7XG4gICAgdmFyIG1ha2VTdG9yZSA9IF9hLm1ha2VTdG9yZSwgX2UgPSBfYS5jb250ZXh0LCBjb250ZXh0ID0gX2UgPT09IHZvaWQgMCA/IHt9IDogX2U7XG4gICAgdmFyIGNyZWF0ZVN0b3JlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFrZVN0b3JlKGNvbnRleHQpOyB9O1xuICAgIGlmIChnZXRJc1NlcnZlcigpKSB7XG4gICAgICAgIHZhciByZXEgPSAoKF9iID0gY29udGV4dCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlcSkgfHwgKChfZCA9IChfYyA9IGNvbnRleHQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jdHgpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5yZXEpO1xuICAgICAgICBpZiAocmVxKSB7XG4gICAgICAgICAgICAvLyBBVFRFTlRJT04hIFRISVMgSVMgSU5URVJOQUwsIERPIE5PVCBBQ0NFU1MgRElSRUNUTFkgQU5ZV0hFUkUgRUxTRVxuICAgICAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20va2lyaWxsLWtvbnNoaW4vbmV4dC1yZWR1eC13cmFwcGVyL3B1bGwvMTk2I2lzc3VlY29tbWVudC02MTE2NzM1NDZcbiAgICAgICAgICAgIGlmICghcmVxLl9fbmV4dFJlZHV4V3JhcHBlclN0b3JlKSB7XG4gICAgICAgICAgICAgICAgcmVxLl9fbmV4dFJlZHV4V3JhcHBlclN0b3JlID0gY3JlYXRlU3RvcmUoKTsgLy8gVXNlZCBpbiBHSVAvR1NTUFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcS5fX25leHRSZWR1eFdyYXBwZXJTdG9yZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlU3RvcmUoKTtcbiAgICB9XG4gICAgLy8gTWVtb2l6ZSB0aGUgc3RvcmUgaWYgd2UncmUgb24gdGhlIGNsaWVudFxuICAgIGlmICghc2hhcmVkQ2xpZW50U3RvcmUpIHtcbiAgICAgICAgc2hhcmVkQ2xpZW50U3RvcmUgPSBjcmVhdGVTdG9yZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc2hhcmVkQ2xpZW50U3RvcmU7XG59O1xuZXhwb3J0IHZhciBjcmVhdGVXcmFwcGVyID0gZnVuY3Rpb24gKG1ha2VTdG9yZSwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IHt9OyB9XG4gICAgdmFyIG1ha2VQcm9wcyA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBfYS5jYWxsYmFjaywgY29udGV4dCA9IF9hLmNvbnRleHQsIF9iID0gX2EuYWRkU3RvcmVUb0NvbnRleHQsIGFkZFN0b3JlVG9Db250ZXh0ID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0b3JlLCBuZXh0Q2FsbGJhY2ssIGluaXRpYWxQcm9wcywgX2MsIHN0YXRlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2QubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUgPSBpbml0U3RvcmUoeyBjb250ZXh0OiBjb250ZXh0LCBtYWtlU3RvcmU6IG1ha2VTdG9yZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIjEuIGdldFByb3BzIGNyZWF0ZWQgc3RvcmUgd2l0aCBzdGF0ZVwiLCBzdG9yZS5nZXRTdGF0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlZ2FjeSBzdHVmZiAtIHB1dCBzdG9yZSBpbiBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkU3RvcmVUb0NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5jdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5jdHguc3RvcmUgPSBzdG9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3RvcmUgPSBzdG9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q2FsbGJhY2sgPSBjYWxsYmFjayAmJiBjYWxsYmFjayhzdG9yZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYyA9IG5leHRDYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2MpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbmV4dENhbGxiYWNrKGNvbnRleHQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSAoX2Quc2VudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFByb3BzID0gKF9jKSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIjMuIGdldFByb3BzIGFmdGVyIGRpc3BhdGNoZXMgaGFzIHN0b3JlIHN0YXRlXCIsIHN0b3JlLmdldFN0YXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFByb3BzOiBpbml0aWFsUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxTdGF0ZTogZ2V0SXNTZXJ2ZXIoKSA/IGdldFNlcmlhbGl6ZWRTdGF0ZShzdGF0ZSwgY29uZmlnKSA6IHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBnZXRJbml0aWFsUGFnZVByb3BzID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRleHQgaXMgc3RvcmUg4oCUIGF2b2lkIGRvdWJsZS13cmFwcGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdnZXRTdGF0ZScgaW4gY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjYWxsYmFjayAmJiBjYWxsYmFjayhjb250ZXh0KV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBtYWtlUHJvcHMoeyBjYWxsYmFjazogY2FsbGJhY2ssIGNvbnRleHQ6IGNvbnRleHQsIGFkZFN0b3JlVG9Db250ZXh0OiB0cnVlIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7IH07XG4gICAgfTtcbiAgICB2YXIgZ2V0SW5pdGlhbEFwcFByb3BzID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgaW5pdGlhbFByb3BzLCBpbml0aWFsU3RhdGU7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIG1ha2VQcm9wcyh7IGNhbGxiYWNrOiBjYWxsYmFjaywgY29udGV4dDogY29udGV4dCwgYWRkU3RvcmVUb0NvbnRleHQ6IHRydWUgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IF9iLnNlbnQoKSwgaW5pdGlhbFByb3BzID0gX2EuaW5pdGlhbFByb3BzLCBpbml0aWFsU3RhdGUgPSBfYS5pbml0aWFsU3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgX19hc3NpZ24oX19hc3NpZ24oe30sIGluaXRpYWxQcm9wcyksIHsgaW5pdGlhbFN0YXRlOiBpbml0aWFsU3RhdGUgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgfTtcbiAgICB9O1xuICAgIHZhciBnZXRTdGF0aWNQcm9wcyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIGluaXRpYWxQcm9wcywgaW5pdGlhbFN0YXRlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBtYWtlUHJvcHMoeyBjYWxsYmFjazogY2FsbGJhY2ssIGNvbnRleHQ6IGNvbnRleHQgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IF9iLnNlbnQoKSwgaW5pdGlhbFByb3BzID0gX2EuaW5pdGlhbFByb3BzLCBpbml0aWFsU3RhdGUgPSBfYS5pbml0aWFsU3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgX19hc3NpZ24oX19hc3NpZ24oe30sIGluaXRpYWxQcm9wcyksIHsgcHJvcHM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBpbml0aWFsUHJvcHMucHJvcHMpLCB7IGluaXRpYWxTdGF0ZTogaW5pdGlhbFN0YXRlIH0pIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7IH07XG4gICAgfTtcbiAgICB2YXIgZ2V0U2VydmVyU2lkZVByb3BzID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZ2V0U3RhdGljUHJvcHMoY2FsbGJhY2spKGNvbnRleHQpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTsgfSk7IH07XG4gICAgfTsgLy8ganVzdCBub3QgdG8gcmVwZWF0IG15c2VsZlxuICAgIHZhciBoeWRyYXRlID0gZnVuY3Rpb24gKHN0b3JlLCBzdGF0ZSkge1xuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogSFlEUkFURSxcbiAgICAgICAgICAgIHBheWxvYWQ6IGdldERlc2VyaWFsaXplZFN0YXRlKHN0YXRlLCBjb25maWcpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBoeWRyYXRlT3JjaGVzdHJhdG9yID0gZnVuY3Rpb24gKHN0b3JlLCBnaWFwU3RhdGUsIGdzcFN0YXRlLCBnc3NwU3RhdGUsIGdpcHBTdGF0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChnc3BTdGF0ZSkge1xuICAgICAgICAgICAgLy8gSWYgR1NQIGhhcyBydW4sIHRoZW4gZ3NwU3RhdGUgd2lsbCBfbm90XyBjb250YWluIHRoZSBkYXRhIGZyb20gR0lQIChpZiBpdCBleGlzdHMpLCBiZWNhdXNlIEdTUCBpcyBydW4gYXQgYnVpbGQgdGltZSxcbiAgICAgICAgICAgIC8vIGFuZCBHSVAgcnVucyBhdCByZXF1ZXN0IHRpbWUuIFNvIHdlIGhhdmUgdG8gaHlkcmF0ZSB0aGUgR0lQIGRhdGEgZmlyc3QsIGFuZCB0aGVuIGRvIGFub3RoZXIgaHlkcmF0ZSBvbiB0aGUgZ3NwU3RhdGUuXG4gICAgICAgICAgICBoeWRyYXRlKHN0b3JlLCBnaWFwU3RhdGUpO1xuICAgICAgICAgICAgaHlkcmF0ZShzdG9yZSwgZ3NwU3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGdzc3BTdGF0ZSB8fCBnaXBwU3RhdGUgfHwgZ2lhcFN0YXRlKSB7XG4gICAgICAgICAgICAvLyBJZiBHU1NQIGhhcyBydW4sIHRoZW4gZ3NzcFN0YXRlIF93aWxsXyBjb250YWluIHRoZSBkYXRhIGZyb20gR0lQIChpZiB0aGVyZSBpcyBhIEdJUCkgYW5kIHRoZSBHU1NQIGRhdGEgY29tYmluZWRcbiAgICAgICAgICAgIC8vIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2tpcmlsbC1rb25zaGluL25leHQtcmVkdXgtd3JhcHBlci9wdWxsLzQ5OSNkaXNjdXNzaW9uX3IxMDE0NTAwOTQxKS5cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIEdTUCBvciBHU1NQIGZvciB0aGlzIHBhZ2UsIGJ1dCB0aGVyZSBpcyBhIEdJUCBvbiBwYWdlIGxldmVsIChub3QgX2FwcCksIHRoZW4gd2UgdXNlIHRoZSBnaXBwU3RhdGUuXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBHU1Agb3IgR1NTUCBhbmQgbm8gR0lQIG9uIHBhZ2UgbGV2ZWwgZm9yIHRoaXMgcGFnZSwgYnV0IHRoZXJlIGlzIGEgR0lQIG9uIF9hcHAgbGV2ZWwsIHRoZW4gd2UgdXNlIHRoZSBnaWFwU3RhdGUuXG4gICAgICAgICAgICBoeWRyYXRlKHN0b3JlLCAoX2EgPSBnc3NwU3RhdGUgIT09IG51bGwgJiYgZ3NzcFN0YXRlICE9PSB2b2lkIDAgPyBnc3NwU3RhdGUgOiBnaXBwU3RhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGdpYXBTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciB1c2VIeWJyaWRIeWRyYXRlID0gZnVuY3Rpb24gKHN0b3JlLCBnaWFwU3RhdGUsIGdzcFN0YXRlLCBnc3NwU3RhdGUsIGdpcHBTdGF0ZSkge1xuICAgICAgICB2YXIgZXZlbnRzID0gdXNlUm91dGVyKCkuZXZlbnRzO1xuICAgICAgICB2YXIgc2hvdWxkSHlkcmF0ZSA9IHVzZVJlZih0cnVlKTtcbiAgICAgICAgLy8gV2Ugc2hvdWxkIG9ubHkgaHlkcmF0ZSB3aGVuIHRoZSByb3V0ZXIgaGFzIGNoYW5nZWQgcm91dGVzXG4gICAgICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkSHlkcmF0ZS5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBldmVudHMgPT09IG51bGwgfHwgZXZlbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldmVudHMub24oJ3JvdXRlQ2hhbmdlU3RhcnQnLCBoYW5kbGVTdGFydCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9PT0gbnVsbCB8fCBldmVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50cy5vZmYoJ3JvdXRlQ2hhbmdlU3RhcnQnLCBoYW5kbGVTdGFydCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCBbZXZlbnRzXSk7XG4gICAgICAgIC8vIHVzZU1lbW8gc28gdGhhdCB3aGVuIHdlIG5hdmlnYXRlIGNsaWVudCBzaWRlLCB3ZSBhbHdheXMgc3luY2hyb25vdXNseSBoeWRyYXRlIHRoZSBzdGF0ZSBiZWZvcmUgdGhlIG5ldyBwYWdlXG4gICAgICAgIC8vIGNvbXBvbmVudHMgYXJlIG1vdW50ZWQuIFRoaXMgbWVhbnMgd2UgaHlkcmF0ZSB3aGlsZSB0aGUgcHJldmlvdXMgcGFnZSBjb21wb25lbnRzIGFyZSBzdGlsbCBtb3VudGVkLlxuICAgICAgICAvLyBZb3UgbWlnaHQgdGhpbmsgdGhhdCBtaWdodCBjYXVzZSBpc3N1ZXMgYmVjYXVzZSB0aGUgc2VsZWN0b3JzIG9uIHRoZSBwcmV2aW91cyBwYWdlIChzdGlsbCBtb3VudGVkKSB3aWxsIHN1ZGRlbmx5XG4gICAgICAgIC8vIGNvbnRhaW4gb3RoZXIgZGF0YSwgYW5kIG1heWJlIGV2ZW4gbmVzdGVkIHByb3BlcnRpZXMsIGNhdXNpbmcgbnVsbCByZWZlcmVuY2UgZXhjZXB0aW9ucy5cbiAgICAgICAgLy8gQnV0IHRoYXQncyBub3QgdGhlIGNhc2UuXG4gICAgICAgIC8vIEh5ZHJhdGluZyBpbiB1c2VNZW1vIHdpbGwgbm90IHRyaWdnZXIgYSByZXJlbmRlciBvZiB0aGUgc3RpbGwgbW91bnRlZCBwYWdlIGNvbXBvbmVudC4gU28gaWYgeW91ciBzZWxlY3RvcnMgZG8gaGF2ZVxuICAgICAgICAvLyBzb21lIGluaXRpYWwgc3RhdGUgdmFsdWVzIGNhdXNpbmcgdGhlbSB0byByZXJ1biBhZnRlciBoeWRyYXRpb24sIGFuZCB5b3UncmUgYWNjZXNzaW5nIGRlZXBseSBuZXN0ZWQgdmFsdWVzIGluc2lkZSB5b3VyXG4gICAgICAgIC8vIGNvbXBvbmVudHMsIHlvdSBzdGlsbCB3b3VsZG4ndCBnZXQgZXJyb3JzLCBiZWNhdXNlIHRoZXJlJ3Mgbm8gcmVyZW5kZXIuXG4gICAgICAgIC8vIEluc3RlYWQsIFJlYWN0IHdpbGwgcmVuZGVyIHRoZSBuZXcgcGFnZSBjb21wb25lbnRzIHN0cmFpZ2h0IGF3YXksIHdoaWNoIHdpbGwgaGF2ZSBzZWxlY3RvcnMgd2l0aCB0aGUgY29ycmVjdCBkYXRhLlxuICAgICAgICB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRIeWRyYXRlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRlT3JjaGVzdHJhdG9yKHN0b3JlLCBnaWFwU3RhdGUsIGdzcFN0YXRlLCBnc3NwU3RhdGUsIGdpcHBTdGF0ZSk7XG4gICAgICAgICAgICAgICAgc2hvdWxkSHlkcmF0ZS5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtzdG9yZSwgZ2lhcFN0YXRlLCBnc3BTdGF0ZSwgZ3NzcFN0YXRlLCBnaXBwU3RhdGVdKTtcbiAgICB9O1xuICAgIC8vIGdpYXBTdGF0ZSBzdGFuZHMgZm9yIGdldEluaXRpYWxBcHBQcm9wcyBzdGF0ZVxuICAgIHZhciB1c2VXcmFwcGVkU3RvcmUgPSBmdW5jdGlvbiAoX2EsIGRpc3BsYXlOYW1lKSB7XG4gICAgICAgIHZhciBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICBpZiAoZGlzcGxheU5hbWUgPT09IHZvaWQgMCkgeyBkaXNwbGF5TmFtZSA9ICd1c2VXcmFwcGVkU3RvcmUnOyB9XG4gICAgICAgIHZhciBnaWFwU3RhdGUgPSBfYS5pbml0aWFsU3RhdGUsIGluaXRpYWxQcm9wcyA9IF9hLmluaXRpYWxQcm9wcywgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImluaXRpYWxTdGF0ZVwiLCBcImluaXRpYWxQcm9wc1wiXSk7XG4gICAgICAgIC8vIGdldFN0YXRpY1Byb3BzIHN0YXRlXG4gICAgICAgIHZhciBnc3BTdGF0ZSA9IChwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMuX19OX1NTRykgPyAoX2IgPSBwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMucGFnZVByb3BzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW5pdGlhbFN0YXRlIDogbnVsbDtcbiAgICAgICAgLy8gZ2V0U2VydmVyU2lkZVByb3BzIHN0YXRlXG4gICAgICAgIHZhciBnc3NwU3RhdGUgPSAocHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzLl9fTl9TU1ApID8gKF9jID0gcHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzLnBhZ2VQcm9wcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmluaXRpYWxTdGF0ZSA6IG51bGw7XG4gICAgICAgIC8vIGdldEluaXRpYWxQYWdlUHJvcHMgc3RhdGVcbiAgICAgICAgdmFyIGdpcHBTdGF0ZSA9ICFnc3BTdGF0ZSAmJiAhZ3NzcFN0YXRlID8gKF9lID0gKF9kID0gcHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzLnBhZ2VQcm9wcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmluaXRpYWxTdGF0ZSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogbnVsbCA6IG51bGw7XG4gICAgICAgIGlmIChjb25maWcuZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCc0LicsIGRpc3BsYXlOYW1lLCAnY3JlYXRlZCBuZXcgc3RvcmUgd2l0aCcsIHtcbiAgICAgICAgICAgICAgICBnaWFwU3RhdGU6IGdpYXBTdGF0ZSxcbiAgICAgICAgICAgICAgICBnc3BTdGF0ZTogZ3NwU3RhdGUsXG4gICAgICAgICAgICAgICAgZ3NzcFN0YXRlOiBnc3NwU3RhdGUsXG4gICAgICAgICAgICAgICAgZ2lwcFN0YXRlOiBnaXBwU3RhdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RvcmUgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluaXRTdG9yZSh7IG1ha2VTdG9yZTogbWFrZVN0b3JlIH0pOyB9LCBbXSk7XG4gICAgICAgIHVzZUh5YnJpZEh5ZHJhdGUoc3RvcmUsIGdpYXBTdGF0ZSwgZ3NwU3RhdGUsIGdzc3BTdGF0ZSwgZ2lwcFN0YXRlKTtcbiAgICAgICAgdmFyIHJlc3VsdFByb3BzID0gcHJvcHM7XG4gICAgICAgIC8vIG9yZGVyIGlzIGltcG9ydGFudCEgTmV4dC5qcyBvdmVyd3JpdGVzIHByb3BzIGZyb20gcGFnZXMvX2FwcCB3aXRoIGdldFN0YXRpY1Byb3BzIGZyb20gcGFnZVxuICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS96ZWl0L25leHQuanMvaXNzdWVzLzExNjQ4XG4gICAgICAgIGlmIChpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLnBhZ2VQcm9wcykge1xuICAgICAgICAgICAgcmVzdWx0UHJvcHMucGFnZVByb3BzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGluaXRpYWxQcm9wcy5wYWdlUHJvcHMpLCBwcm9wcy5wYWdlUHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGp1c3Qgc29tZSBjbGVhbnVwIHRvIHByZXZlbnQgcGFzc2luZyBpdCBhcyBwcm9wcywgd2UgbmVlZCB0byBjbG9uZSBwcm9wcyB0byBzYWZlbHkgZGVsZXRlIGluaXRpYWxTdGF0ZVxuICAgICAgICBpZiAoKF9mID0gcHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzLnBhZ2VQcm9wcykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmluaXRpYWxTdGF0ZSkge1xuICAgICAgICAgICAgcmVzdWx0UHJvcHMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJvcHMpLCB7IHBhZ2VQcm9wczogX19hc3NpZ24oe30sIHByb3BzLnBhZ2VQcm9wcykgfSk7XG4gICAgICAgICAgICBkZWxldGUgcmVzdWx0UHJvcHMucGFnZVByb3BzLmluaXRpYWxTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1bndyYXAgZ2V0SW5pdGlhbFBhZ2VQcm9wc1xuICAgICAgICBpZiAoKF9nID0gcmVzdWx0UHJvcHMgPT09IG51bGwgfHwgcmVzdWx0UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3VsdFByb3BzLnBhZ2VQcm9wcykgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmluaXRpYWxQcm9wcykge1xuICAgICAgICAgICAgcmVzdWx0UHJvcHMucGFnZVByb3BzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHJlc3VsdFByb3BzLnBhZ2VQcm9wcyksIHJlc3VsdFByb3BzLnBhZ2VQcm9wcy5pbml0aWFsUHJvcHMpO1xuICAgICAgICAgICAgZGVsZXRlIHJlc3VsdFByb3BzLnBhZ2VQcm9wcy5pbml0aWFsUHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RvcmU6IHN0b3JlLCBwcm9wczogX19hc3NpZ24oX19hc3NpZ24oe30sIGluaXRpYWxQcm9wcyksIHJlc3VsdFByb3BzKSB9O1xuICAgIH07XG4gICAgdmFyIHdpdGhSZWR1eCA9IGZ1bmN0aW9uIChDb21wb25lbnQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCcvIVxcXFwgWW91IGFyZSB1c2luZyBsZWdhY3kgaW1wbGVtZW50YXRpb24uIFBsZWFzZSB1cGRhdGUgeW91ciBjb2RlOiB1c2UgY3JlYXRlV3JhcHBlcigpIGFuZCB3cmFwcGVyLnVzZVdyYXBwZWRTdG9yZSgpLicpO1xuICAgICAgICAvL1RPRE8gQ2hlY2sgaWYgcGFnZXMvX2FwcCB3YXMgd3JhcHBlZCBzbyB0aGVyZSdzIG5vIG5lZWQgdG8gd3JhcCBhIHBhZ2UgaXRzZWxmXG4gICAgICAgIHZhciBXcmFwcGVkQ29tcG9uZW50ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB1c2VXcmFwcGVkU3RvcmUocHJvcHMsIFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUpLCBzdG9yZSA9IF9hLnN0b3JlLCBjb21iaW5lZFByb3BzID0gX2EucHJvcHM7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJvdmlkZXIsIHsgc3RvcmU6IHN0b3JlIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9fYXNzaWduKHt9LCBjb21iaW5lZFByb3BzKSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgV3JhcHBlZENvbXBvbmVudC5kaXNwbGF5TmFtZSA9IFwid2l0aFJlZHV4KFwiLmNvbmNhdChDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcsIFwiKVwiKTtcbiAgICAgICAgaWYgKCdnZXRJbml0aWFsUHJvcHMnIGluIENvbXBvbmVudCkge1xuICAgICAgICAgICAgV3JhcHBlZENvbXBvbmVudC5nZXRJbml0aWFsUHJvcHMgPSBDb21wb25lbnQuZ2V0SW5pdGlhbFByb3BzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBXcmFwcGVkQ29tcG9uZW50O1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0U2VydmVyU2lkZVByb3BzOiBnZXRTZXJ2ZXJTaWRlUHJvcHMsXG4gICAgICAgIGdldFN0YXRpY1Byb3BzOiBnZXRTdGF0aWNQcm9wcyxcbiAgICAgICAgZ2V0SW5pdGlhbEFwcFByb3BzOiBnZXRJbml0aWFsQXBwUHJvcHMsXG4gICAgICAgIGdldEluaXRpYWxQYWdlUHJvcHM6IGdldEluaXRpYWxQYWdlUHJvcHMsXG4gICAgICAgIHdpdGhSZWR1eDogd2l0aFJlZHV4LFxuICAgICAgICB1c2VXcmFwcGVkU3RvcmU6IHVzZVdyYXBwZWRTdG9yZSxcbiAgICB9O1xufTtcbi8vIExlZ2FjeVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1hbm9ueW1vdXMtZGVmYXVsdC1leHBvcnRcbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiAobWFrZVN0b3JlLCBjb25maWcpIHtcbiAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0ge307IH1cbiAgICBjb25zb2xlLndhcm4oJy8hXFxcXCBZb3UgYXJlIHVzaW5nIGxlZ2FjeSBpbXBsZW1lbnRhdGlvbi4gUGxlYXNlIHVwZGF0ZSB5b3VyIGNvZGU6IHVzZSBjcmVhdGVXcmFwcGVyKCkgYW5kIHdyYXBwZXIud2l0aFJlZHV4KCkuJyk7XG4gICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIobWFrZVN0b3JlLCBjb25maWcpLndpdGhSZWR1eDtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next-redux-wrapper/es6/index.js\n");

/***/ })

};
;